
using TMPro;
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{
    public TextMeshProUGUI scoreTxtInGame;
    public ScoreCounter score;

    public GameObject instancesParent;
    public GameObject[] obstacles;
    public GameObject star;
    public GameObject colorSwitcher;

    public GameObject ball;
    public Camera mainCamera;

    private float spawnEnd;

    private void Start()
    {
        generateSegment(ball.transform.position.y);
    }

    //Generates a segment with a random obstacle, free space and randomly placed star and color switcher.
    //Color switcher is generated by chance in the free space and star can be spawned anywhere within the segment.
    //All spawned objects are parented to the "instances" object for easier cleanup.
    public void generateSegment(float startPoint)
    {
        float breakSpaceSize = Random.Range(600, 1200);

        //Colorswitcher is spawned within the empty space with 40% chance.
        if (Random.value < 0.4f)
        {
            float colorSwitcherPos = Random.Range(200, breakSpaceSize - 200);
            float colorSwitcherSpawnY = startPoint + colorSwitcherPos;
            GameObject z = Instantiate(colorSwitcher, new Vector2(colorSwitcher.transform.position.x, colorSwitcherSpawnY), colorSwitcher.transform.rotation);
            z.GetComponent<ColorSwitcher>()._ballColor = ball.GetComponent<BallColor>();
            z.transform.parent = instancesParent.transform;
        }

        GameObject chosenObstacle = obstacles[Random.Range(0, obstacles.Length)];
        float obstacleSpawnY = startPoint + breakSpaceSize;

        //Places a random obstacle after random empty space
        //Obstacle 2 needs to be offset in order to be correctly placed
        GameObject x;
        if (chosenObstacle.name == "obstacle2")
        {
            x = Instantiate(chosenObstacle, new Vector2(chosenObstacle.transform.position.x, obstacleSpawnY + 338.079f), chosenObstacle.transform.rotation);
            x.transform.parent = instancesParent.transform;
        }
        else
        {
            x = Instantiate(chosenObstacle, new Vector2(chosenObstacle.transform.position.x, obstacleSpawnY), chosenObstacle.transform.rotation);
            x.transform.parent = instancesParent.transform;
        }

        //Forwards the ball reference to the chosen obstacle in case of collision
        if (x.GetComponentAtIndex(1) is Obstacle1)
        {
            x.GetComponentAtIndex<Obstacle1>(1).ball = ball;
        }
        else if (x.GetComponentAtIndex(1) is Obstacle2)
        {
            x.GetComponentAtIndex<Obstacle2>(1).ball = ball;
        }
        else if (x.GetComponentAtIndex(1) is Obstacle3)
        {
            x.GetComponentAtIndex<Obstacle3>(1).ball = ball;
        }

        //gets the location of obstacles upperbounds in order to set correct end point of the segment.
        for (int i = 0; i < x.transform.childCount; i++)
        {
            Transform child = x.transform.GetChild(i);

            if (child.tag == "UpperBound")
            {
                spawnEnd = x.transform.GetChild(i).position.y;
                break;
            }
        }

        //Generates a star placed randomly within the segment
        float starSpawnY = Random.Range(startPoint + 200, spawnEnd - 200);
        GameObject y = Instantiate(star, new Vector3(star.transform.position.x, starSpawnY, 2), star.transform.rotation);

        y.GetComponent<Star>().scoreTxtInGame = scoreTxtInGame;
        y.GetComponent<Star>().score = score;
        y.transform.parent = instancesParent.transform;
    }

    private void Update()
    {
        //Checks whether the end of segment has been reached and then generates a new one starting from there
        Vector2 viewPos = mainCamera.WorldToViewportPoint(new Vector2(0, spawnEnd));
        if (viewPos.y <= 1.0F)
        {
            generateSegment(spawnEnd);
        }
    }
}
